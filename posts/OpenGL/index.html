<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Learning OpenGL based on C++ | Odrin's blog</title><meta name="author" content="Odrin He"><meta name="copyright" content="Odrin He"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="The Cherno的OpenGL系列教程 欢迎来到OpenGLOpenGL（Open Graphic Libraries）是什么？一种图形API，并且允许我们访问GPU，本质是一种规范，并没有统一的实现，具体的函数实现在你使用的操作系统的显卡驱动上。本系列只是集中于OpenGL本身的代码，以便让你明白OpenGL是如何运行的，并掌握使用OpenGL开发游戏引擎的作用。其他的类似API:Direc">
<meta property="og:type" content="article">
<meta property="og:title" content="Learning OpenGL based on C++">
<meta property="og:url" content="https://odrin2.github.io/posts/OpenGL/index.html">
<meta property="og:site_name" content="Odrin&#39;s blog">
<meta property="og:description" content="The Cherno的OpenGL系列教程 欢迎来到OpenGLOpenGL（Open Graphic Libraries）是什么？一种图形API，并且允许我们访问GPU，本质是一种规范，并没有统一的实现，具体的函数实现在你使用的操作系统的显卡驱动上。本系列只是集中于OpenGL本身的代码，以便让你明白OpenGL是如何运行的，并掌握使用OpenGL开发游戏引擎的作用。其他的类似API:Direc">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://odrin2.github.io/img/tom.jpeg">
<meta property="article:published_time" content="2023-05-01T04:31:02.000Z">
<meta property="article:modified_time" content="2023-08-29T07:04:07.967Z">
<meta property="article:author" content="Odrin He">
<meta property="article:tag" content="Learning">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://odrin2.github.io/img/tom.jpeg"><link rel="shortcut icon" href="/img/station.png"><link rel="canonical" href="https://odrin2.github.io/posts/OpenGL/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Learning OpenGL based on C++',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-29 15:04:07'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/tom.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Odrin's blog"><span class="site-name">Odrin's blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Learning OpenGL based on C++</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-01T04:31:02.000Z" title="发表于 2023-05-01 12:31:02">2023-05-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-29T07:04:07.967Z" title="更新于 2023-08-29 15:04:07">2023-08-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Computer-Graphics/">Computer Graphics</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">3.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>14分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Learning OpenGL based on C++"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><p>The Cherno的OpenGL系列教程</p>
<h2 id="欢迎来到OpenGL"><a href="#欢迎来到OpenGL" class="headerlink" title="欢迎来到OpenGL"></a>欢迎来到OpenGL</h2><p>OpenGL（Open Graphic Libraries）是什么？一种图形API，并且允许我们访问GPU，本质是一种规范，并没有统一的实现，具体的函数实现在你使用的操作系统的显卡驱动上。<br>本系列只是集中于OpenGL本身的代码，以便让你明白OpenGL是如何运行的，并掌握使用OpenGL开发游戏引擎的作用。<br>其他的类似API:Direct3D,Vulcan,Metal</p>
<p>OpenGL功能图：<br><img src="/posts/OpenGL//OpenGL.png" alt="OpenGL"></p>
<p>下面介绍GLFW、GLEW、GLAD：</p>
<p>GLFW就是提供一个初始化、管理OpenGL窗口的库，因为OpenGL本质上不提供这些功能。<br>GLFW (Graphics Library Framework) is a lightweight utility library for use with OpenGL. It provides programmers with the ability to create and manage windows and OpenGL contexts, as well as handle joystick, keyboard and mouse input.GLFW is used in programs that <strong>require a window</strong>, due to OpenGL not providing any mechanisms for creating the necessary contexts, managing windows, user input, timing, etc.GLFW is not a user-interface library,platform-specific library, image-loading library or a threading library. Additionally, it cannot render independently or playback sound. </p>
<p>GLEW其实就是帮你在你的显卡驱动上找到显卡厂商实现的OpenGL的函数<br>GLEW (The OpenGL Extension Wrangler Library) is a cross-platform open-source C/C++ extension loading library. GLEW provides efficient run-time mechanisms for <code>determining which OpenGL extensions</code> are supported on the target platform. OpenGL core and extension functionality is exposed in a single header file. GLEW has been tested on a variety of operating systems, including Windows, Linux, Mac OS X, FreeBSD, Irix, and Solaris.</p>
<p>GLAD和GLEW差不多。</p>
<h2 id="设置OpenGL和在C-中创建一个窗口"><a href="#设置OpenGL和在C-中创建一个窗口" class="headerlink" title="设置OpenGL和在C++中创建一个窗口"></a>设置OpenGL和在C++中创建一个窗口</h2><p>GLFW是配合OpenGL使用的轻量级工具库，全称 Graphics Library Framework（图形库框架）</p>
<p>我们会开始使用GLFW库写一个能显示一个三角形的窗口。</p>
<ul>
<li><p>创建项目<img src="/posts/OpenGL//Project.png" alt="Project"></p>
</li>
<li><p>添加依赖库：首先我们需要从官网下载<a target="_blank" rel="noopener" href="https://www.glfw.org/download.html">GLFW库</a>的编译后文件（也可以下载源代码自己编译），本文下载的是<code>glfw-3.3.8.bin.WIN32</code>版本的。然后将包中的<code>lib-vc2022</code>(库文件,本节只使用了静态库)和<code>include</code>(头文件)复制到自己的项目文件夹下的<code>dependences</code>(自己创建)文件夹下。</p>
</li>
<li><p>VS2022设置：</p>
</li>
<li><ul>
<li>你需要在<code>项目设置 - C/C++ - 常规 - 附加包含目录</code>中添加(就是找到依赖库的头文件) <code>$(SolutionDir)Dependences\GLFW\include</code>;</li>
</ul>
</li>
<li><ul>
<li>在<code>项目设置 - 链接器 - 常规 - 附加包含目录</code>中添加<code>$(SolutionDir)Dependences\GLFW\lib-vc2022</code>;</li>
</ul>
</li>
<li><ul>
<li>在<code>项目设置 - 链接器 - 输入 - 附加依赖项</code>中添加<code>glfw3.lib;opengl32.lib;User32.lib;Gdi32.lib;Shell32.lib</code>(此项可以保留VS的原设置，这里只是为了说明哪些库在工作);</li>
</ul>
</li>
<li><p>复制GLFW官网的<a target="_blank" rel="noopener" href="https://www.glfw.org/documentation.html">窗口示例代码</a>到你的<code>Application.cpp</code>文件中，并修改使其能显示三角形。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GLFWwindow* window;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the library */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a windowed mode window and its OpenGL context */</span></span><br><span class="line">    window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">&quot;Hello World&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!window)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make the window&#x27;s context current */</span></span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Render here */</span></span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//画三角形</span></span><br><span class="line">        <span class="built_in">glBegin</span>(GL_TRIANGLES);</span><br><span class="line">        <span class="built_in">glVertex2f</span>(<span class="number">-0.5f</span>, <span class="number">-0.5f</span>);</span><br><span class="line">        <span class="built_in">glVertex2f</span>( <span class="number">0.0f</span>, <span class="number">0.5f</span>);</span><br><span class="line">        <span class="built_in">glVertex2f</span>( <span class="number">0.5f</span>, <span class="number">-0.5f</span>);</span><br><span class="line">        <span class="built_in">glEnd</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Poll for and process events */</span></span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你在运行时出现了依赖库的link错误问题，比如（在输出列表中查看）：</p>
</li>
<li><p>1&gt;glfw3.lib(win32_monitor.obj) : error LNK2019: 无法解析的外部符号 __imp__CreateDCW@16，函数 __glfwPlatformGetGammaRamp 中引用了该符号</p>
</li>
</ul>
<p>你可以去Google”CreateDCW”,你会在微软的文档中发现这个函数属于哪个库？<code>Gdi32.lib</code>,然后将库名添加到链接的附加依赖项中。</p>
<h2 id="在C-中使用现代OpenGL"><a href="#在C-中使用现代OpenGL" class="headerlink" title="在C++中使用现代OpenGL"></a>在C++中使用现代OpenGL</h2><p>目标： 在GLFW创建窗口后初始化GLEW</p>
<p>我们同样需要在GLEW网站上下载，然后在项目中设置引用库，如同上一节一样的设置。</p>
<p>设置好之后仍然会有链接问题，因为还有一个细节，你会在<code>glew.h</code>文件中发现：由于没有定义<code>GLEW_STATIC</code>字符，编译器会默认加载动态链接库而不是静态的，本节使用的是静态链接库，所以你需要 <code>项目属性 - C/C++ - 预处理器定义</code> 中添加 <code>GLEW_STATIC</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span>  <span class="comment">//必须在包含其他OpenGL相关文件前包含glew.h,因为glew.h中的字符不允许先被定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">    <span class="comment">/* 与前文一致故省略 */</span></span><br><span class="line">    <span class="comment">/* Make the window&#x27;s context current */</span></span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化glew</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//打印一个版本信息</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">glGetString</span>(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line">    <span class="comment">/* 与前文一致故省略 */</span></span><br></pre></td></tr></table></figure>

<h2 id="使用现代OpenGL画一个三角形"><a href="#使用现代OpenGL画一个三角形" class="headerlink" title="使用现代OpenGL画一个三角形"></a>使用现代OpenGL画一个三角形</h2><p>上节我们在GLFW提供的窗口中，用比较传统的方式画了一个三角形，本节，我们将使用现代的OpenGL方法实现同样的目标。</p>
<p>先介绍一些概念<br>顶点缓冲区:所谓顶点缓冲区，其实就是内存缓冲区，一个内存字节数组，用以存储多个Vertex。<br>着色器(shader)：一个运行在显卡上的程序，可以理解为它会从缓冲区读取数据帮助你绘图。<br>顶点(vertex)：一个顶点就像是一个类，可以有多个属性，比如：位置、纹理、法线等</p>
<p>选择缓冲区、着色器并绘图是一个状态，这就是OpenGL的原理，它是一个状态机。</p>
<p>删除原先在循环内的三角形代码，并在循环外加入以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> positions[<span class="number">6</span>] = &#123;</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">         <span class="number">0.0f</span>, <span class="number">0.5f</span>,</span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>,&amp;buffer);            <span class="comment">//创建缓冲区</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER,buffer);<span class="comment">//绑定意味着使用</span></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">6</span>*<span class="built_in">sizeof</span>(<span class="type">float</span>),positions,GL_STATIC_DRAW);  <span class="comment">//写入数据</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(<span class="type">float</span>) * <span class="number">2</span>, <span class="number">0</span>); </span><br></pre></td></tr></table></figure>
<p>要学会RTFM(Read the fucking manual),例如访问<a target="_blank" rel="noopener" href="https://docs.gl/">OpenGL文档</a>页面查看<code>glVertexAttribPointer</code>函数的作用。该函数起到调用顶点属性的作用。<br><img src="/posts/OpenGL//manual.png" alt="Manual"><br>文档上的描述一般都比较学术化，不是很容易明白，函数的具体作用如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">glVertexAttribPointer</span><span class="params">(	GLuint index,   <span class="comment">//读取数据索引，索引可能指向顶点的各种属性，比如0指向位置、1指向纹理等等</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            GLint size,     <span class="comment">//每个通用顶点属性的组件数，和实际字节大小无关</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            GLenum type,    <span class="comment">//属性数据类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            GLboolean normalized, <span class="comment">//归一化处理向量</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            GLsizei stride,  <span class="comment">//步长，一个顶点到下一个顶点的字节数</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">const</span> GLvoid * pointer)</span></span>;<span class="comment">//第一个通用顶点属性的第一个组件的偏移量，初始值为 0</span></span><br></pre></td></tr></table></figure>

<h2 id="OpenGL的着色器原理"><a href="#OpenGL的着色器原理" class="headerlink" title="OpenGL的着色器原理"></a>OpenGL的着色器原理</h2><p>上节我们画了一个三角形，但是并没有写着色器(shader)，代码却执行成功了，这是因为显卡驱动默认为我提供了一个着色器。</p>
<p>显卡要如何处理我们发送给它的数据？这就是着色器存在的原因</p>
<p>对于大多数图形编程来说有：顶点着色器、片段着色器（又称为像素着色器）等等着色器。这些着色器在实际执行DrawCall指令并在屏幕上绘制的过程叫“渲染管道”，简化的说DrawCall会先调用顶点着色器（我们有三个顶点，会调用三次，决定了每个顶点的位置），然后经过一些过程，在调用像素着色器（会将每个需要光栅化的像素运行一次，决定了每个像素的状态），然后还有一些过程把图画出来。</p>
<p>值得注意的是，要注意像素着色器会为每个需要渲染的像素执行一次，可能会代价很大。<br>假如你在计算光源，每个像素都有一个颜色值，并且受到环境、光源的影响，而像素着色器会综合计算并且显示一个最终的像素值，消耗很多资源。</p>
<h2 id="在OpenGL中写一个着色器"><a href="#在OpenGL中写一个着色器" class="headerlink" title="在OpenGL中写一个着色器"></a>在OpenGL中写一个着色器</h2><p>目标：实现是一个着色器，并从文件中读取着色数据，正确显示</p>
<p>逻辑图：</p>
<p>在res目录下创建shaders文件，并在内创建basic.shader文件，具体内容如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#shader vertex</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">0</span>) in vec4 position;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	gl_Position = position;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#shader fragment</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">0</span>) out vec4 color;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	color = <span class="built_in">vec4</span>(<span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.8</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ShaderProgramSource</span></span><br><span class="line">&#123;</span><br><span class="line">    std::string VertexSource;</span><br><span class="line">    std::string FragmentSource;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> ShaderProgramSource <span class="title">ParseShader</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">stream</span><span class="params">(filepath)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">ShaderType</span></span><br><span class="line">    &#123;</span><br><span class="line">        NONE = <span class="number">-1</span>, VERTEX = <span class="number">0</span>, FRAGMENT = <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::string line;</span><br><span class="line">    std::stringstream ss[<span class="number">2</span>];</span><br><span class="line">    ShaderType type = ShaderType::NONE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(stream, line))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">&quot;#shader&quot;</span>) != std::string::npos)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">&quot;vertex&quot;</span>) != std::string::npos)</span><br><span class="line">                type = ShaderType::VERTEX;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">&quot;fragment&quot;</span>) != std::string::npos)</span><br><span class="line">                type = ShaderType::FRAGMENT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ss[(<span class="type">int</span>)type] &lt;&lt; line &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; ss[<span class="number">0</span>].<span class="built_in">str</span>(),ss[<span class="number">1</span>].<span class="built_in">str</span>() &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="built_in">glShaderSource</span>(id,<span class="number">1</span>,&amp;src,<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">glCompileShader</span>(id);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result);</span><br><span class="line">    <span class="keyword">if</span> (result == GL_FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line">        <span class="built_in">glGetShaderiv</span>(id, GL_INFO_LOG_LENGTH, &amp;length);</span><br><span class="line">        <span class="type">char</span>* message = (<span class="type">char</span>*)<span class="built_in">alloca</span>(length * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(id, length, &amp;length, message);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to compile&quot;</span> &lt;&lt; (type == GL_VERTEX_SHADER ? <span class="string">&quot;vertex&quot;</span> : <span class="string">&quot;fragment&quot;</span>) &lt;&lt; <span class="string">&quot; shader!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">glDeleteShader</span>(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">CompileShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">CompileShader</span>(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, vs);</span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, fs);</span><br><span class="line">    <span class="built_in">glLinkProgram</span>(program);</span><br><span class="line">    <span class="built_in">glValidateProgram</span>(program);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glDeleteShader</span>(vs);</span><br><span class="line">    <span class="built_in">glDeleteShader</span>(fs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> program;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GLFWwindow* window;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the library */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a windowed mode window and its OpenGL context */</span></span><br><span class="line">    window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">&quot;Hello World&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!window)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make the window&#x27;s context current */</span></span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">glGetString</span>(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> positions[<span class="number">6</span>] = &#123;</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">         <span class="number">0.0f</span>, <span class="number">0.5f</span>,</span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>,&amp;buffer);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER,buffer);<span class="comment">//绑定意味着使用</span></span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">6</span>*<span class="built_in">sizeof</span>(<span class="type">float</span>),positions,GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(<span class="type">float</span>) * <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ShaderProgramSource source = <span class="built_in">ParseShader</span>(<span class="string">&quot;res/shaders/Basic.shader&quot;</span>);</span><br><span class="line">    <span class="comment">/* Test</span></span><br><span class="line"><span class="comment">    std::cout &lt;&lt; &quot;VERTEX&quot; &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">    std::cout &lt;&lt; source.VertexSource &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">    std::cout &lt;&lt; &quot;FRAGMENT&quot; &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">    std::cout &lt;&lt; source.FragmentSource &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> shader = <span class="built_in">CreateShader</span>(source.VertexSource, source.FragmentSource);</span><br><span class="line">    <span class="built_in">glUseProgram</span>(shader);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Render here */</span></span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glDrawArrays</span>(GL_TRIANGLES,<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Poll for and process events */</span></span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glDeleteProgram</span>(shader);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在OpenGL中的索引缓冲区"><a href="#在OpenGL中的索引缓冲区" class="headerlink" title="在OpenGL中的索引缓冲区"></a>在OpenGL中的索引缓冲区</h2><p>前面的代码实现的效果是画了一个三角形？如果想利用上面的代码画一个正方形，那么我们需要把两个等腰直角三角形拼接成一个正方形。当然这不一定是画正方形的最好办法，只是为了说明画两个三角形表示一个正方形的办法，会有两个顶点的冗余重复，如果图形过多、过复杂这种现象会造成严重的内存资源浪费。为了解决这个问题，我们需要索引缓冲区。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改数据</span></span><br><span class="line"><span class="type">float</span> positions[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="comment">//0</span></span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="comment">//1</span></span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="comment">//2</span></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="comment">//3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> indices[] = &#123;</span><br><span class="line">    <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,</span><br><span class="line">    <span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点缓冲区</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>,&amp;buffer);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER,buffer);<span class="comment">//绑定意味着使用</span></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">4</span> * <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>),positions,GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(<span class="type">float</span>) * <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//索引缓冲区</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ibo;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;ibo);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, ibo);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>), indices,GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure>
<p>循环窗口中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>

<h2 id="如何在OpenGL中处理错误"><a href="#如何在OpenGL中处理错误" class="headerlink" title="如何在OpenGL中处理错误"></a>如何在OpenGL中处理错误</h2><p>OpenGL有两种错误信息函数<code>glDebugMessageCallback()</code> <code>glGetError()</code></p>
<p>我们在这里使用第二种函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ASSERT(x) <span class="keyword">if</span> (!(x)) __debugbreak();</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLCall(x) GLClearError();\</span></span><br><span class="line"><span class="meta">    x;\</span></span><br><span class="line"><span class="meta">    ASSERT(GLLogCall(#x,__FILE__,__LINE__));</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GLClearError</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">glGetError</span>() != GL_NO_ERROR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">GLLogCall</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* function, <span class="type">const</span> <span class="type">char</span>* file, <span class="type">int</span> line)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (GLenum error = <span class="built_in">glGetError</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[OpenGL Error] (&quot;</span> &lt;&lt; error &lt;&lt; <span class="string">&quot;) &quot;</span>  &lt;&lt; function &lt;&lt;</span><br><span class="line">            <span class="string">&quot; &quot;</span> &lt;&lt; file &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 省略 */</span></span><br><span class="line"><span class="comment">/* 循环窗体中 */</span></span><br><span class="line">        <span class="comment">//glDrawArrays(GL_TRIANGLES,0,6);</span></span><br><span class="line">        <span class="built_in">GLCall</span>(<span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>));</span><br></pre></td></tr></table></figure>
<p>我们可以用这种方法测试诸多语句</p>
<h2 id="OpenGL统一变量"><a href="#OpenGL统一变量" class="headerlink" title="OpenGL统一变量"></a>OpenGL统一变量</h2><p>修改<code>basic.shader</code>文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#shader vertex</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">0</span>) in vec4 position;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	gl_Position = position;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#shader fragment</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">0</span>) out vec4 color;</span><br><span class="line"></span><br><span class="line">uniform vec4 u_Color;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	color = u_Color;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>主文件中<br>使用统一变量，并写了一个闪动效果</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> shader = <span class="built_in">CreateShader</span>(source.VertexSource, source.FragmentSource);</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glUseProgram</span>(shader));</span><br><span class="line"></span><br><span class="line"><span class="built_in">GLCall</span>(<span class="type">int</span> location = <span class="built_in">glGetUniformLocation</span>(shader,<span class="string">&quot;u_Color&quot;</span>));</span><br><span class="line"><span class="built_in">ASSERT</span>(location != <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glUniform4f</span>(location, <span class="number">0.8f</span>, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> r = <span class="number">0.0f</span>;</span><br><span class="line"><span class="type">float</span> increment = <span class="number">0.05f</span>;</span><br><span class="line"><span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Render here */</span></span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT)); </span><br><span class="line"></span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glUniform4f</span>(location, r, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>));</span><br><span class="line">    <span class="comment">//glDrawArrays(GL_TRIANGLES,0,6);</span></span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r &gt; <span class="number">1.0f</span>)</span><br><span class="line">        increment = <span class="number">-0.05f</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (r &lt; <span class="number">0.0f</span>)</span><br><span class="line">        increment = <span class="number">0.05f</span>;</span><br><span class="line"></span><br><span class="line">    r += increment;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Poll for and process events */</span></span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="将前面的代码抽象成类"><a href="#将前面的代码抽象成类" class="headerlink" title="将前面的代码抽象成类"></a>将前面的代码抽象成类</h2><p>前面的代码都是简单的流程化的任务实现演示，让我们将这些功能抽象成类，使我们的代码更加工业化。<br>如图：<br><img src="/posts/OpenGL//Class.png" alt="Class"><br>这些代码的实现效果<br><img src="/posts/OpenGL//Result.png" alt="Result"></p>
<h3 id="OpenGL纹理"><a href="#OpenGL纹理" class="headerlink" title="OpenGL纹理"></a>OpenGL纹理</h3><p>我们尝试把一个PNG图片当做纹理加载出来（只是示例，游戏引擎中一般有自己的纹理文件格式）</p>
<p>使用了stb_imgae.h</p>
<h3 id="OpenGL中的数学"><a href="#OpenGL中的数学" class="headerlink" title="OpenGL中的数学"></a>OpenGL中的数学</h3><p>我们要通过glm数学库解决4:3图标的问题</p>
<h3 id="OpenGL-使用imGUI控件"><a href="#OpenGL-使用imGUI控件" class="headerlink" title="OpenGL 使用imGUI控件"></a>OpenGL 使用imGUI控件</h3><p>使用直接调控我们的显示对象</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>——————</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://odrin2.github.io/">Odrin He</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://odrin2.github.io/posts/OpenGL/">https://odrin2.github.io/posts/OpenGL/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://odrin2.github.io" target="_blank">Odrin's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Learning/">Learning</a><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="/img/tom.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/Games101/" title="Games101"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Games101</div></div></a></div><div class="next-post pull-right"><a href="/posts/OS/" title="Operating System"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Operating System</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/C++/" title="C++"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-11</div><div class="title">C++</div></div></a></div><div><a href="/posts/Effective%20C++/" title="Effective C++"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-14</div><div class="title">Effective C++</div></div></a></div><div><a href="/posts/Database/" title="Computer Database"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-26</div><div class="title">Computer Database</div></div></a></div><div><a href="/posts/Games101/" title="Games101"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-21</div><div class="title">Games101</div></div></a></div><div><a href="/posts/CS_Tools/" title="MIT:&quot; The missing-semesters &quot;"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-15</div><div class="title">MIT:&quot; The missing-semesters &quot;</div></div></a></div><div><a href="/posts/Network/" title="Computer Network"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-21</div><div class="title">Computer Network</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/tom.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Odrin He</div><div class="author-info__description">Talk is cheap. Show me the code.</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Odrin2"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Odrin2" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:heyu10202@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">詹姆斯表示你知道的。。。     =。=</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0OpenGL"><span class="toc-number">1.</span> <span class="toc-text">欢迎来到OpenGL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AEOpenGL%E5%92%8C%E5%9C%A8C-%E4%B8%AD%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AA%97%E5%8F%A3"><span class="toc-number">2.</span> <span class="toc-text">设置OpenGL和在C++中创建一个窗口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8C-%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%8E%B0%E4%BB%A3OpenGL"><span class="toc-number">3.</span> <span class="toc-text">在C++中使用现代OpenGL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%8E%B0%E4%BB%A3OpenGL%E7%94%BB%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="toc-number">4.</span> <span class="toc-text">使用现代OpenGL画一个三角形</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenGL%E7%9A%84%E7%9D%80%E8%89%B2%E5%99%A8%E5%8E%9F%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">OpenGL的着色器原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8OpenGL%E4%B8%AD%E5%86%99%E4%B8%80%E4%B8%AA%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">6.</span> <span class="toc-text">在OpenGL中写一个着色器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8OpenGL%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">7.</span> <span class="toc-text">在OpenGL中的索引缓冲区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8OpenGL%E4%B8%AD%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF"><span class="toc-number">8.</span> <span class="toc-text">如何在OpenGL中处理错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenGL%E7%BB%9F%E4%B8%80%E5%8F%98%E9%87%8F"><span class="toc-number">9.</span> <span class="toc-text">OpenGL统一变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E5%89%8D%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E6%8A%BD%E8%B1%A1%E6%88%90%E7%B1%BB"><span class="toc-number">10.</span> <span class="toc-text">将前面的代码抽象成类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenGL%E7%BA%B9%E7%90%86"><span class="toc-number">10.1.</span> <span class="toc-text">OpenGL纹理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenGL%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6"><span class="toc-number">10.2.</span> <span class="toc-text">OpenGL中的数学</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenGL-%E4%BD%BF%E7%94%A8imGUI%E6%8E%A7%E4%BB%B6"><span class="toc-number">10.3.</span> <span class="toc-text">OpenGL 使用imGUI控件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">10.4.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/Python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/" title="无题">无题</a><time datetime="2023-07-25T01:12:54.418Z" title="发表于 2023-07-25 09:12:54">2023-07-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/Effective%20C++/" title="Effective C++">Effective C++</a><time datetime="2023-06-14T05:03:23.000Z" title="发表于 2023-06-14 13:03:23">2023-06-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/Games101/" title="Games101">Games101</a><time datetime="2023-05-21T01:00:02.000Z" title="发表于 2023-05-21 09:00:02">2023-05-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/OpenGL/" title="Learning OpenGL based on C++">Learning OpenGL based on C++</a><time datetime="2023-05-01T04:31:02.000Z" title="发表于 2023-05-01 12:31:02">2023-05-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/OS/" title="Operating System">Operating System</a><time datetime="2023-04-26T00:11:48.000Z" title="发表于 2023-04-26 08:11:48">2023-04-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By Odrin He</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>